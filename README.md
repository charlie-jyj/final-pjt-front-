# final pjt



## 📖프로젝트 구조

- 백엔드 서버: django rest-framework를 활용한 api 서버
  - DRF
- 프론트엔드 서버: vue.js를 활용한 프론트 서버
  - 개발환경
    - Vue.js 2 +
    - Node 14 X
  - Stack
    - HTML5
    - CSS3
    - Javascript
  - node modules
    - vuex
    - router
    - axios
    - fullcalendar
    - splidejs
    - fullcalendar
    - vue-cookies
    - vue-awesome-swiper
    - kakao link
    - lodash
    - vue-star-rating
    - autocomplete-vue
    
    

## 📑상세 정보

### 1. 팀원 정보 및 업무 분담 내역 



#### 팀원

- 유태규 (팀장)
- 정유진 (팀원)



#### 업무 분담 내역

   - 공통: 구현할 기능 및 api end points 설정, 최종 점검 및 발표 자료 구성 
   - 유태규: backend api 서버 구축
   -  정유진: frontend 서버 구축

   

### 2. 목표 서비스 구현 및 실제 구현 정도



   #### 목표 서비스

##### 필수 서비스

- 영화 추천기능
- 커뮤니티 기능 (댓글, 리뷰), 평점(0-5)

##### 추가 서비스

- 영화 검색어 자동완성
- 닉네임 정하기 
- 광고 기능
- 영화 스케줄러



#### 실제 구현 정도

| 필수 여부 | 기능명               | 구현 여부 | 비고                             |
| --------- | -------------------- | --------- | -------------------------------- |
| O         | 영화 추천 기능       | V         |                                  |
| O         | 커뮤니티 기능        | V         |                                  |
| O         | 영화 평가 기능       | V         |                                  |
|           | 영화 검색어 자동완성 | V         |                                  |
|           | 닉네임 정하기        | V         |                                  |
|           | 광고 기능            | X         | static 파일의 저작권 문제로 보류 |
|           | 영화 스케줄러        | V         |                                  |
|           | 카카오톡 공유        | V         |                                  |



### 3. 데이터베이스 모델링(ERD)



### ![img](https://lh3.googleusercontent.com/RPeD0nf82SzK4b_Mu51pXgKTheg4ynFcvpCP3EvPavjIO2KUNiZR9g6tny6KSzuDzz_--lcrN7UkbaccHsqbE8NfbRk-OG5njf_ZvtzKA2b8iRr-eK3_JgfvmZhrkwL4akzwqPJD)![img](https://lh5.googleusercontent.com/JTtmpERNgzXcgLs0-zn9SwmV18RG0JAzu_GxgSjLWPQv1W2f7V3LVLCE8_WvxWroBGGqEuWM_XRo1GG7CnfWvpNjW4tGdIuveOcGECtuOBItplOZviJwaBwSBudbN1eeOBlBAX3R)

   

### 4. 필수 기능에 대한 설명

   - 처음 회원가입 시에 몇 개의 영화에 대해 평점을 매길 수 있도록 하고,
   - 이를 바탕으로 선호하는 영화 시리즈가 무엇인지 결정, 이 영화 시리즈에 해당하는 영화 중 평점을 주지 않은 영화들을 보지 않은 영화라고 간주하여 추천
   - 익명 닉네임 설정 기능: 선호하는 영화 시리즈가 결정되면, 그 시리즈에 해당하는 캐릭터를 결정할 수 있는 설문을 사용자에게 제시, 설문 답변 결과로 정해진 캐릭터와 무작위 형용사를 조합하여 유저 닉네임 결정.
   - 영화 스케쥴러: 영화에 후속작 관계를 이용하여 영화 관람 순서를 사전에 어느정도 정해둠. 실제로 영화를 보고자 하는 시간에 대한 정보를 입력하면, 이 조건에 맞는 영화들을 그 시간에 맞게 배치하여 사용자에게 제시



### 5. 배포 서버 URL
   - 백엔드 서버 : http://movie-pick.com/
   - 프론트엔드 서버 : https://moviepickvue.com/



## 📝 개발일지

- 🎄5/20  (목)🎄
  - 기획 회의
    - 전반적인 디자인 컨셉 결정 
    - 역할 분담
    - 데이터베이스 모델링
    - 구현 기능 구상
    - 프로젝트 일정 계획
  - 느낌점
    - 데이터 베이스 모델링을 초반에 꼼꼼하게 해두었던 것이 도움이 많이 되었다
    - 프론트 엔드 작업을 하면서 백단에서 어떤 구조를 가진 데이터가 넘어올 지를 예상할 수 있었기 때문에 많은 도움이 되었다
    - 내가 흔히 사용하던 API 문서 하나를 만들기 위해서 백과 프론트가 활발하게 소통해야 하고 서로 잦은 피드백이 필요하다는 것 
    
    
  
- ✨5/21 (금)✨
  
  - 뷰 프로젝트 구조 설정
    - 모듈화하여  3가지로 분리 
      1. accounts
         1. 회원가입
         2. 설문조사
         3. 로그인
         4. 프로필
      2. movies
         1. 영화 전체 리스트 
         2. 추천 영화 리스트
         3. 영화 세부 사항
         4. 영화 평가 코멘트
      3. reviews
         1.  커뮤니티 게시물
         2. 댓글
  - 회원가입 구현
    - 회원가입 과정
    - 선호 영화 조사 >> 설문 조사 >> 결과 공유
  - 느낀점
    - SPA 를 구현할 때에는 컴포넌트를 만들어 그를 재사용 하므로 초반에 컴포넌트의 상위/ 하위 관계를 설정하는 것이 어려웠다 
    - 분명 만들면서 새롭게 추가되는 것도 있을테지만 초반에 틀을 잘 잡아두어야 
    - 관련성이 높은 속성과 메서드를 하나의 모듈로 분리하는 것이 가능하다는 생각
    - 마치 클래스를 응집도 높게 디자인하는 것과 비슷하게 느껴졌다 
    - 그를 위해서는 논리적으로 의미를 분리할 수 있어야 했다 
    - 물론 중복되는 영역이 없는 것은 아니지만 
    - 최대한 영화와 관련된 일은 영화 모듈만이 하게 만들고 커뮤니티와 관련된 일은 커뮤니티만이 하도록 분리한다.
    
    
  
- 🎁5/22 (토)🎁
  
  - accounts 완성 및 마무리
    - 회원가입 완성 
    - 로그인 완성
    - 카카오 link (공유) 구현 (배포 이후 수정 필요)
      - vue 에서 카카오 API 를 사용할 때에는 Kakao 변수를 전역 변수를 선언해야 한다
  - 입력 form , detail 화면 출력할 Modal 설치 
    - modal 을 보던 중에 다른 컴포넌트로 redirect 할 경우에는 꼭 modal을 dispose 해야 화면이 먹통이 되지 않는다
  - 느낀점
    - 아직 서버와 연결한 상태가 아니기 때문에 구현하면서 dummy data를 사용 했다
    - 추후에 서버와 연결하고 나면 내가 사용한 attribute 값을 전반적으로 수정해야 한다.
    - 처음에 dummy data를 만들 때 부터 실제로 response로 받게되는 data 객체와 최대한 비슷하게 만들면 좋겠지만 
    - 아직 백단도 구현 중이기 때문에 한계가 있으므로 
    - 나중에 빠짐없이 수정하는 것이 관건 (출력되어야 할 정보가 출력되지 않는 불상사가 벌어질 수 있기 때문에)
    - 외부 라이브러리를 사용할 때에는 공식 문서를 바이블로 여기고 숙지해야 내 뜻대로 사용할 수 있다는 점을 뼈저리게 느꼈다 
    - Vue instance의 llife cycle를 이해한 상황이 아니면 왜 코드가 뜻대로 동작하지 않는지 이해할 수가 없어서 문서를 보면서 
    - 어느 시점에 객체나 메서드를 call 해야 할지를 결정했다. 
    - 이는 앞으로 프로젝트를 할 때에도 꼭 염두에 두고 구현해야 할 듯 하다.
    
    
  
- 👕5/23 (일)🩳
  
  - movie page 구현 
    - 영화 목록 조회 
    - 영화 상세 
    - 영화 검색 + 자동완성 (진행중)
    - 영화 찜하기 (수정중)
  - 느낀점
    - 기존에 존재하는 모듈/라이브러리를 사용하여 구현중인데
    - 수 많은 라이브러리 중에서 어떤 것이 좋을지 알아 보는 눈이 필요한 듯 하다 
    - 많은 사람이 이미 사용하고 있을 수록 문제를 만났을 때에 레퍼런스를 찾기가 좋아 
    - 라이브러리의 다운로드 수를 감안하여 선택했다
    - 시작 할 때만 하여도 바닐라 자바스크립트 코드를 많이 사용하고 싶었는데 
    - 평점 등록을 위한 star rating 을 직접 만들어 보려다가 포기하였다 
    - 아직 서버와의 연결은 생각하지 않고 내가 가진 데이터로 출력이 되는지를 확인하고 있는데 
    - 나중에 비동기 연결을 axios 로 할 때에 꼼꼼하게 연결해야 하므로 주석을 써두었고 
    - drf 라는 js  문서로 경로 파일을 따로 관리하고 있다.
    - 디테일 페이지에 유튜브 API로 트레일러를 넣을까 하였는데 
    - 검색한 동영상이 트레일러라는 보장이 없어서 (search query  를 어떻게 던져야 할지) 보류
    - 왜 시간이 전반적으로 오래 걸릴까 생각해보았는데, 디자인을 어떻게 할지 스토리 보드 또는 와이어프레임을 작성하지 않은 채로 시작해서 그런 듯 하다
    - 2학기 프로젝트를 할 때에는 초반에 와이어 프레임을 꼭 작성해야지 
    - 월요일에 커뮤니티를 구현할 때에는 디자인적으로 힘을 빼고 빠르게 쳐내는 것에 집중할 생각이다.
    
    
  
- 🎪5/24 (월)🎪
  
  - community CRUD 완성
  - 게시글 댓글 CRUD 완성
  - 느낀점
    - 제일 골치 아팠던 부분은 수정 부분이었다.
    - 원래 수정값을 input value 에 초기화 하여 사용하려 했었는데
    - vue 에서는 textarea 의 경우  v-model 을 연동하여 값을 주입해야 했다
    - 그런데 내가 모달을 사용하는 것이 문제가 되었다
    - 모달은 눈에 보이지 않을 뿐 내가 수정하기 디테일을 호출하기 이전에 이미 created 와  mounted 가 끝나있는 상황이었기 때문에
    - 내가 data의 기본값을 주어야 하는 시점이 문제가 되었다 
    - 모달이  show 된 후에 활성화가 되면 updated 가 되기 때문에 (data의 변경으로 인해)
    - updated 메서드를 사용하되 무작정 data 를 주입하면 
    - 내가 모달 안의 input field 에 값을 입력 할 때마다 data 에 변화가 생기고 그러면 updated 메서드가 호출되면서 값이 초기화 되는 문제점이 발생했다
    - 따라서 created 가 될 때에 말도 안 되는 값을 (!@#$) 입력해두고 
    - 초기값 (!@#$) 일 때만 default 값 (수정 전 내용) 을 주입했다
    - vue 를 사용하다보면 undefined 를 만나게 되는 순간이 많은데 
    - vue 객체의 life cycle 을 잘 고려해야 한다는 점을 다시 한 번 주의
    - 아쉽게 느껴지는 점은, 생성 form 과 수정 form 을 충분히 합쳐서 하나의  form 으로 재사용할 수 있었을 것 같은데 선뜻 어떻게 해야할지 모르겠어서 그냥 분리했다
    - input hidden tag 에 값을 넣어두고 value 값에 따라서 update 이거나 create 라고 판단해도 될 것 같고
    - 아니면 update  할 경우에 state 에 update 객체를 올려두고 (default 는 빈 객체 {}) 
    - getters:Objects.key(object).length 하여 빈 객체가 아니라면 update 상황이라고 가정
      - object 가 아니라 null 상황일 때에는 위의 함수가 call 될 수 없음 주의 
      - && 단축 평가를 사용하여 if (object&&Object.keys(object).length) 해야 정상 작동
    - 좋아요 버튼을 구현 할 때에.. v-if 로 조건문 분기 할 것이 아니라 classList toggle 하는 것도 좋았을 것이다  
    
    
- 5/25 (화)
  - Full calendar 적용하여 profile page 완성
  
  - 느낀점
  
    - 멘붕의 연속이었던 것은 
    - 내가 promise 를 사용하는 이유를 간과했던 점
    - request를 보내고 response가 돌아오기 전에 javascript 가 스택의 다른 함수들을 먼저 실행하므로 (동시성 모델)
    - 나는 빈화면을 만나야만 했던 것이다
    - 따라서 axios 의 then 함수들을 메서드 체이닝 하여
    -  response 가 돌아왔을 때 actions 을 call 하는 식으로 해결하였다
    - script 를 전역으로 활용할 수 있었을 때에는 함수를 call 하거나 특정 이벤트를 trigger 하는 것이 편리했는데
    - vue 프레임워크 내부에서 특정 DOM 에 event 를 trigger 하는 것이 너무 불편했다
    -  state 를 사용하여 어찌저찌 해결하기는 했찌만
    - 그리고 무한 스크롤을 달 때에도 SPA 이다 보니 
    - 내가 원하는 페이지가 1페이지였고 이 곳에서만 무한 스크롤을 하고 싶었는데
    - vue 기준 1페이지 = 2페이지 이기 때문에 2페이지에서도 무한 스크롤이 일어나는 낭패가...
    - 그래서 리뷰페이지에서 스크롤을 하고 있는데 무비 페이지 또한 스크롤이 end 를 만났다고 판단하여 영화를 새로 load 해오는 문제가 발생했다
    - 페이지 라우터가 이동할 때에 create 되는 것을 이용하여 state 에 현재 페이지 값을 정해두고 내가 현재 1페이지에 있을 때에는 1페이지의 스크롤 이벤트가 발생하도록 제한했다
    - vue 란./.. 참 신기하기도 하고
    - 확실히 상태관리를 통해 전체적으로 변화를 반영하여 주는 것은 큰 장점이다
    - 예상대로 작동하지 않는 것은 내 이론 공부의 부족이다 
    - 자동완성이 내 뜻대로 되지 않고 있다 
    - 역시나 메서드가 실행되고 서버와 통신하고 돌아오는 과정에서
    - '정'을 입력하면 정이 포함된 리스트를 서버에서 들고오지만 
    - 그 사이에 나는 '정유' 를 입력하였기 때문에 자동완성 리스트가 펼쳐지지 않는 문제가 있다
  
    
- 🎲5/26 (수)🎲
  - 해결한 것들
  
  - 스케줄러
  
    - 공식 문서를 참고하여 다 때려 박았다
  
  - 영화 찜하기
  
    - 찜하기 버튼이 반영이 될 때가 있고 안 될 때가 있어서 (색깔 변화)
    - 디테일을 불러올 때마다 프로필 URL에 리퀘스트를 보내서 내가 현재 보고 있는 여화 객체가 찜한 영화인지를 매번 확인하도록 변경했다
    - 이렇게 매번 자주 요청을 보내도 되는 것일가?
    - 한 번에 알뜰하게 챙겨오고 싶었지만 값이 갱신된 것을 반영하기 위해서는 프로필을 다녀오는 수밖에 없다고 결론 지었다
    - 그리고 프로필을 다녀올 때 axios then 을 메서드 체이닝 하여 
    - 프로필 다녀오기 >> 응답하면 movie_to_see 객체 갱신 >> 갱신이 끝나면 변화 반영
  
  - 무한 스크롤
  
    - 페이지네이션을 서버에서 해주기 때문에 수월하게 끝났다
    - 원래 페이지 넘버를 클릭해서 페이지를 넘기는 방식으로 구현할 가 했는데
    - 페이지 넘버를 매번 계산해주기가 너무 싫어서 
    - django 에서 dtl 쓰고 template 쓸 때에는 django 가 알아서 전체 게시물 수, offset, 현재 페이지 고려해서 페이지네이션 시작 넘버와 끝 넘버를 자동으로 계산해줬는데 
    - 이를 서버에서 페이지네이션 클래스 하나 파서 계산해달라고 말하기에는 무리가 있었고
    -  DRF 에서 어떻게 처리해주는 지 모를 일이라 
    - 무한 스크롤을 하면 offset 으로 다음 게시물 리스트를 기존의 리스트에 push 해주는 것으로 구현이 가능했기 때문에 편리하다
    - 그리고 요즘 사이트 들이 무한 스크롤을 많이 하니까...
    - 모바일 친화적이기 때문인가 라고 막연히 생각한다
  
  - 자동완성
  
    - 공식 문서를 다시 훑어 보았다 
    - 굳이 actions 에게 처리를 넘기지 않고
    - 컴포넌트 영역 안에서 axios 를 import 하여 
    - 바로 프로미스 객체 자체를 반환하는 식으로 해결했다
    - 모듈의 공식문서를 보니 return 값으로 프로미스를 허용하기 때문에 따로 변환 절차 없이 반환이 가능했다
  
    

- 🎃5/27 (목)🎃
  - 배포
    - Netlify
    - domain 구매
    - https 인증
  - 발표 PPT 작성